"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "observe", {
  enumerable: true,
  get: function get() {
    return _observerUtil.observe;
  }
});
Object.defineProperty(exports, "unobserve", {
  enumerable: true,
  get: function get() {
    return _observerUtil.unobserve;
  }
});
exports.Component = exports.sharedComponentData = void 0;

var _react = require("react");

var _observerUtil = require("@nx-js/observer-util");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var isNative = typeof HTMLElement == 'undefined';
var bindComponentExcludes = ['constructor', 'getSnapshotBeforeUpdate', 'render', 'updated', 'beforeUnmount'];
var bindInstanceExcludes = ['constructor', '__defineGetter__', '__defineSetter__', 'hasOwnProperty', '__lookupGetter__', '__lookupSetter__', 'isPrototypeOf', 'propertyIsEnumerable', 'toString', 'valueOf', '__proto__'];
var observableExcludes = ['props', 'context', 'refs', 'updater', 'state'];

var sharedComponentData = function sharedComponentData(object) {
  var shared = (0, _observerUtil.observable)(object); // Do not allow use of asynchronous operations in constructor, since changes to member variables will not be observed

  var constructorStr = object.constructor.toString();
  var idx = constructorStr.indexOf('\n');

  if (idx != -1) {
    idx += 1;

    while (constructorStr[idx] == ' ') {
      idx += 1;
    }

    if (constructorStr.startsWith('var _this', idx)) throw new Error('Detected use of asynchronous operation in constructor. Use a separate function for such operations that you call after the sharedComponentData object has been made.');
  } // Bind methods


  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.getOwnPropertyNames(Object.getPrototypeOf(object))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var name = _step.value;
      if (!bindInstanceExcludes.includes(name)) shared[name] = shared[name].bind(shared);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return shared;
};

exports.sharedComponentData = sharedComponentData;

// The same observable must be used elsewhere or else components will not rerender
var Component =
/*#__PURE__*/
function (_ReactComponent) {
  _inherits(Component, _ReactComponent);

  _createClass(Component, null, [{
    key: "instance",
    // Returns the last instance
    value: function instance() {
      if (!Component.instances) return null;
      var instances = Component.instances[this.name];
      if (!instances || instances.length == 0) return null;
      return instances[instances.length - 1];
    }
  }, {
    key: "instances",
    value: function instances() {
      if (!Component.instances) return [];
      var instances = Component.instances[this.name];
      if (!instances) return [];
      return instances;
    }
  }]);

  function Component() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Component);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Component)).call.apply(_getPrototypeOf2, [this].concat(args)));
    if (!Component.instances) Component.instances = {};
    var instances = Component.instances[_this.constructor.name];
    if (!instances) instances = Component.instances[_this.constructor.name] = [];
    instances.push(_assertThisInitialized(_assertThisInitialized(_this))); // Bind methods

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = Object.getOwnPropertyNames(Object.getPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this))))[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var name = _step2.value;

        if (!name.startsWith('shouldComponent') && !name.startsWith('componentWill') && !name.startsWith('componentDid') && !name.startsWith('UNSAFE_component') && !bindComponentExcludes.includes(name)) {
          _this[name] = _this[name].bind(_assertThisInitialized(_assertThisInitialized(_this)));
        }
      } // Create getters and setters for properties. Objects are made observable.

    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    _this._reactSimplifiedRender = _this.render;
    _this._reactSimplifiedVarsSet = false;

    _this.render = function () {
      if (!_this._reactSimplifiedVarsSet) {
        _this._reactSimplifiedVarsSet = true;
        var ownPropertyNames = Object.getOwnPropertyNames(_assertThisInitialized(_assertThisInitialized(_this)));
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          var _loop = function _loop() {
            var name = _step3.value;

            if (typeof _this[name] != 'function' && !name.startsWith('_react') && !observableExcludes.includes(name)) {
              if (typeof _this[name] == 'undefined') {
                throw new Error('Detected uninitialized or undefined property ' + name + ' in class ' + _this.constructor.name + '. Since such properties are unsafe to use in controlled components, you must initialize this property or use null instead of undefined.');
              }

              if (_typeof(_this[name]) == 'object' && _this[name] != null) {
                // Do not make React.createRef() objects observable
                if (Object.isSealed(_this[name])) {
                  var keys = Object.keys(_this[name]);
                  if (keys.length == 1 && keys[0] == 'current') return "continue";
                }

                _this['_reactSimplifiedVar_' + name] = (0, _observerUtil.observable)(_this[name]);
              } else {
                _this['_reactSimplifiedVar_' + name] = _this[name];
              }

              Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), name, {
                get: function get() {
                  return _this['_reactSimplifiedVar_' + name];
                },
                set: function set(value) {
                  if (value instanceof _react.Component || !isNative && value instanceof HTMLElement) {
                    _this['_reactSimplifiedNoRerenderVar_' + name] = true;
                  }

                  if (_typeof(value) == 'object' && value != null && !_this['_reactSimplifiedNoRerenderVar_' + name]) {
                    _this['_reactSimplifiedVar_' + name] = (0, _observerUtil.observable)(value);
                  } else {
                    _this['_reactSimplifiedVar_' + name] = value;
                  }

                  if (!_this['_reactSimplifiedNoRerenderVar_' + name]) _this.setState({});
                  return true;
                }
              });
            }
          };

          for (var _iterator3 = ownPropertyNames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _ret = _loop();

            if (_ret === "continue") continue;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      return _this._reactSimplifiedRender();
    }; // Schedule rerender when observable objects change


    _this.render = (0, _observerUtil.observe)(_this.render, {
      scheduler: function scheduler() {
        return _this.setState({});
      },
      lazy: true
    });
    _this._reactSimplifiedComponentDidMount = _this.componentDidMount;

    _this.componentDidMount = function () {
      if (_this.mounted) return _this.mounted();
      if (_this._reactSimplifiedComponentDidMount) return _this._reactSimplifiedComponentDidMount();
    }; // Disable rerender when component is about to be unmounted


    _this._reactSimplifiedComponentWillUnmount = _this.componentWillUnmount;

    _this.componentWillUnmount = function () {
      var instances = Component.instances[_this.constructor.name];
      instances.splice(instances.indexOf(_assertThisInitialized(_assertThisInitialized(_this))), 1);
      (0, _observerUtil.unobserve)(_this.render);
      if (_this.beforeUnmount) return _this.beforeUnmount();
      if (_this._reactSimplifiedComponentWillUnmount) return _this._reactSimplifiedComponentWillUnmount();
    }; // For easier react-router usage, call componentWillUnmount and componentDidMount when props.match.params changes.


    _this._reactSimplifiedComponentDidUpdate = _this.componentDidUpdate;

    _this.componentDidUpdate = function (prevProps, prevState, snapshot) {
      if (_this.beforeUnmount || _this._reactSimplifiedComponentWillUnmount || _this.mounted || _this._reactSimplifiedComponentDidMount) {
        if (!prevProps.match && _this.props.match || prevProps.match && !_this.props.match) {
          if (_this.beforeUnmount) _this.beforeUnmount();else if (_this._reactSimplifiedComponentWillUnmount) _this._reactSimplifiedComponentWillUnmount();
          if (_this.mounted) _this.mounted();else if (_this._reactSimplifiedComponentDidMount) _this._reactSimplifiedComponentDidMount();
        } else if (prevProps.match && _this.props.match) {
          var prevParams = prevProps.match.params;
          var params = _this.props.match.params;

          if (prevParams && params && _typeof(prevParams) == 'object' && _typeof(params) == 'object' ? Object.keys(prevParams).length != Object.keys(params).length || Object.keys(params).some(function (key) {
            return prevParams[key] !== params[key];
          }) : prevParams !== params) {
            if (_this.beforeUnmount) _this.beforeUnmount();else if (_this._reactSimplifiedComponentWillUnmount) _this._reactSimplifiedComponentWillUnmount();
            if (_this.mounted) _this.mounted();else if (_this._reactSimplifiedComponentDidMount) _this._reactSimplifiedComponentDidMount();
          }
        }
      }

      if (_this.updated) return _this.updated(prevProps, prevState, snapshot);
      if (_this._reactSimplifiedComponentDidUpdate) return _this._reactSimplifiedComponentDidUpdate(prevProps, prevState, snapshot);
    };

    return _this;
  }

  return Component;
}(_react.Component);

exports.Component = Component;